================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-02T19:34:37.179Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
api/v1/__init__.py
api/v1/dashboard.py
core/config.py
database.py
main.py
models.py
services/__init__.py
services/crud.py
services/llm_models.py
services/utils.py

================================================================
Repository Files
================================================================

================
File: api/v1/__init__.py
================
# This file is intentionally left blank.

================
File: api/v1/dashboard.py
================
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.ext.asyncio import AsyncSession
import pandas as pd
from ...database import get_db
from ...models import TableData
from ...services.llm_models import ClaudeClient
from ...services.utils import generate_data_description

dashboard_router = APIRouter()

@dashboard_router.post("/generate-dashboard")
async def generate_dashboard(table_data: TableData, db: AsyncSession = Depends(get_db)):
    try:
        # Convert the received data to a pandas DataFrame
        df = pd.DataFrame(table_data.data, columns=table_data.columns)
        
        # Sample the data if it's large
        if len(df) > 1000:
            sample_size = min(1000, int(len(df) * 0.1))
            df_sample = df.sample(n=sample_size, random_state=42)
            is_sample = True
        else:
            df_sample = df
            is_sample = False
        
        # Generate a data description
        data_description = generate_data_description(df_sample)
        
        # Create the prompt for Claude
        prompt = f"""
        You are an expert Python developer specializing in data visualization and Streamlit dashboards.
        Based on the following data description{' (note: this is based on a sample of the full dataset)' if is_sample else ''}, generate a complete, runnable Streamlit dashboard code:

        {data_description}

        The code should:
        1. Import necessary libraries (pandas, streamlit, plotly, etc.)
        2. Load the data (assume it's saved as 'data.csv')
        3. Create appropriate visualizations based on the data types and potential relationships
        4. Organize the visualizations in a clear, user-friendly Streamlit layout
        5. Include any necessary data processing or transformations
        6. Add interactive elements where appropriate (e.g., dropdowns for selecting columns to visualize)
        7. Ensure the code is complete and can be run as-is by the user
        8. If the description is based on a sample, include code to handle potential differences in the full dataset

        Provide only the Python code without any additional explanations.
        """

        # Call Claude API to generate the dashboard code
        claude_client = ClaudeClient()
        dashboard_code = claude_client.generate_response(prompt)
        
        return {"dashboard_code": dashboard_code}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

================
File: core/config.py
================
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    APP_NAME: str = "AutoDash API"
    DEBUG_MODE: bool = True
    DATABASE_URL: str
    SYNC_DATABASE_URL: str
    TEST_DATABASE_URL: str = "sqlite+aiosqlite:///./test.db"
    OPENAI_KEY: str	
    CLAUDE_API_KEY: str
    GH_CLIENT_ID: str
    GH_CLIENT_SECRET: str

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8'
    )

    @property
    def DATABASE_URL_TO_USE(self):
        return self.TEST_DATABASE_URL if os.getenv("TESTING") else self.DATABASE_URL
    
settings = Settings()

================
File: database.py
================
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from .core.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=True)

AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session

================
File: main.py
================
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.ext.asyncio import AsyncSession
from .api.v1.dashboard import dashboard_router
import httpx
import os
from dotenv import load_dotenv
from .models import UserCreate, UserUpdate, UserInDB, GitHubCallbackRequest
from .database import get_db
from .services import crud
from .core.config import settings

# Load environment variables
load_dotenv()

app = FastAPI()

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Replace with your frontend URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(dashboard_router, prefix="/api/v1")

# GitHub App credentials
GITHUB_CLIENT_ID = settings.GH_CLIENT_ID
GITHUB_CLIENT_SECRET = settings.GH_CLIENT_SECRET
GITHUB_CALLBACK_URL = "http://localhost:3000/github/callback"  # Update this to your frontend callback URL

@app.post("/github/callback")
async def github_callback(request: GitHubCallbackRequest, db: AsyncSession = Depends(get_db)):
    try:
        # Exchange code for access token
        token_url = "https://github.com/login/oauth/access_token"
        token_params = {
            "client_id": GITHUB_CLIENT_ID,
            "client_secret": GITHUB_CLIENT_SECRET,
            "code": request.code,
            "redirect_uri": GITHUB_CALLBACK_URL,
        }
        headers = {"Accept": "application/json"}

        async with httpx.AsyncClient() as client:
            token_response = await client.post(token_url, params=token_params, headers=headers)

        if token_response.status_code != 200:
            raise HTTPException(status_code=400, detail=f"Failed to obtain access token: {token_response.text}")

        token_data = token_response.json()
        access_token = token_data.get("access_token")

        if not access_token:
            raise HTTPException(status_code=400, detail="Access token not found in response")

        # Fetch user information
        user_url = "https://api.github.com/user"
        user_headers = {
            "Authorization": f"token {access_token}",
            "Accept": "application/json",
        }

        async with httpx.AsyncClient() as client:
            user_response = await client.get(user_url, headers=user_headers)

        if user_response.status_code != 200:
            raise HTTPException(status_code=400, detail=f"Failed to fetch user information: {user_response.text}")

        github_user_data = user_response.json()

        # Create or update user in database
        user_data = UserCreate(
            github_id=github_user_data["id"],
            login=github_user_data["login"],
            name=github_user_data.get("name"),
            email=github_user_data.get("email"),
            avatar_url=github_user_data.get("avatar_url")
        )
        
        db_user = await crud.get_user_by_github_id(db, github_id=user_data.github_id)
        if db_user:
            db_user = await crud.update_user(db, db_user=db_user, user_update=UserUpdate(**user_data.dict()))
        else:
            db_user = await crud.create_user(db, user=user_data)

        # Return access token and user information
        return {
            "access_token": access_token,
            "user": UserInDB.from_orm(db_user).dict()
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/users/{user_id}", response_model=UserInDB)
async def read_user(user_id: int, db: AsyncSession = Depends(get_db)):
    db_user = await crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

@app.put("/users/{user_id}", response_model=UserInDB)
async def update_user(user_id: int, user: UserUpdate, db: AsyncSession = Depends(get_db)):
    db_user = await crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return await crud.update_user(db, db_user=db_user, user_update=user)

@app.delete("/users/{user_id}", response_model=UserInDB)
async def delete_user(user_id: int, db: AsyncSession = Depends(get_db)):
    db_user = await crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return await crud.delete_user(db, user_id=user_id)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

================
File: models.py
================
from datetime import datetime
from typing import Any, List, Optional
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base
from pydantic import BaseModel

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    github_id = Column(Integer, unique=True, index=True)
    login = Column(String, unique=True, index=True)
    name = Column(String, nullable=True)
    email = Column(String, nullable=True)
    avatar_url = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

# Pydantic models for API
class UserBase(BaseModel):
    github_id: int
    login: str
    name: Optional[str] = None
    email: Optional[str] = None
    avatar_url: Optional[str] = None

class UserCreate(UserBase):
    pass

class UserUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[str] = None
    avatar_url: Optional[str] = None

class UserInDB(UserBase):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True

class GitHubCallbackRequest(BaseModel):
    code: str

class TableData(BaseModel):
    columns: List[str]
    data: List[List[Any]]

================
File: services/__init__.py
================
# This file is intentionally left blank.

================
File: services/crud.py
================
from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession
from ..models import User, UserCreate, UserUpdate

async def get_user(db: AsyncSession, user_id: int):
    result = await db.execute(select(User).filter(User.id == user_id))
    return result.scalars().first()

async def get_user_by_github_id(db: AsyncSession, github_id: int):
    result = await db.execute(select(User).filter(User.github_id == github_id))
    return result.scalars().first()

async def get_users(db: AsyncSession, skip: int = 0, limit: int = 100):
    result = await db.execute(select(User).offset(skip).limit(limit))
    return result.scalars().all()

async def create_user(db: AsyncSession, user: UserCreate):
    db_user = User(**user.model_dump())
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    return db_user

async def update_user(db: AsyncSession, db_user: User, user_update: UserUpdate):
    for key, value in user_update.dict(exclude_unset=True).items():
        setattr(db_user, key, value)
    await db.commit()
    await db.refresh(db_user)
    return db_user

async def delete_user(db: AsyncSession, user_id: int):
    user = await get_user(db, user_id)
    if user:
        await db.delete(user)
        await db.commit()
    return user

================
File: services/llm_models.py
================
import anthropic
import os
from dotenv import load_dotenv
from abc import ABC, abstractmethod

load_dotenv()

class AIModel(ABC):
    @abstractmethod
    def generate_response(self, prompt):
        pass

class ClaudeClient(AIModel):
    def __init__(self):
        self.client = anthropic.Anthropic(api_key=os.getenv("CLAUDE_API_KEY"))

    def generate_response(self, prompt):
        response = self.client.messages.create(
            model="claude-3-5-sonnet-20240620",
            max_tokens=8000,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        return ''.join(block.text for block in response.content)

================
File: services/utils.py
================
from http.client import HTTPException
import anthropic
import httpx
import os

CLAUDE_API_KEY = os.getenv("CLAUDE_API_KEY")
CLAUDE_API_URL = os.getenv("CLAUDE_API_URL")

def generate_data_description(df):
    description = []
    description.append(f"The dataset contains {df.shape[0]} rows and {df.shape[1]} columns.")
    description.append("\nColumns and their data types:")
    for col in df.columns:
        description.append(f"- {col}: {df[col].dtype}")
    
    numeric_columns = df.select_dtypes(include=['int64', 'float64']).columns
    categorical_columns = df.select_dtypes(include=['object']).columns
    
    if len(numeric_columns) > 0:
        description.append("\nNumeric columns:")
        for col in numeric_columns:
            description.append(f"- {col}: min={df[col].min()}, max={df[col].max()}, mean={df[col].mean():.2f}")
    
    if len(categorical_columns) > 0:
        description.append("\nCategorical columns:")
        for col in categorical_columns:
            description.append(f"- {col}: {df[col].nunique()} unique values")
    
    return "\n".join(description)
